\documentclass{article}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{fullpage}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{url}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{enumitem}
\usepackage{amsmath}

\definecolor{mygreen}{rgb}{0,0.6,0}

% set the default code style
\lstset{
    language=C++,
    frame=tb, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=left, % display line numbers on the left
    commentstyle=\color{mygreen}, % comment color
    keywordstyle=\color{blue}, % keyword color
    stringstyle=\color{red}, % string color
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

\parindent0in
\pagestyle{plain}
\thispagestyle{plain}

\newcommand{\assignment}{Homework 2}
\newcommand{\duedate}{August 13, 2019}


% \renewcommand\thesubsection{\arabic{subsection}}

\title{Homework 2}
\date{}

\begin{document}

Fundação Getulio Vargas\hfill\\
Estruturas de Dados e Algoritmos\hfill\textbf{\assignment}\\
Aluno: Marcelo Bianchi Barata Ribeiro\\
Prof.\ Jorge Poco\hfill\textbf{Due:}: \duedate\\
\smallskip\hrule\bigskip

{\let\newpage\relax\maketitle}
\maketitle


\section{Red-Black Trees}

I am attaching a binary tree source code (\texttt{bst-0.0.cpp}) with the methods insert, delete and print. Your job would be to implement a Red-Black Tree with the functions insert, remove and print. 

To test your code you can follow the examples described in the document \texttt{anexo1.pdf}. In addition, you might be interested in the document \texttt{anexo2.pdf} for a more detailed description of this tree, there is also some Java code that might be useful. 

Note, your code must be implemented in C++ and based in the BST class I'm providing you. Grading would be as follow:

\begin{enumerate}[label=(\alph*)]
  \item \textbf{(2.5pts)} insert 
  \item \textbf{(2.5pts)} remove 
\end{enumerate}

An example of the main function is: 

\begin{lstlisting}
int main() {
  // this constructor must call the function insert multiple times 
  // respecting the order
  RBTree tree(41, 38, 31, 12, 19, 8);
  tree.print();

  // testing the remove function
  tree.remove(8);
  tree.print();
}
\end{lstlisting}

\textbf{Resposta}:\\
Ver arquivo rbt.cpp.

Como referências, usei:
\begin{itemize}
	\item Livro "Introduction to Algorithms", capítulo 13 (CORMEN, Thomas et al).
	\item Slide L3 do curso de Standford que está sendo utilizado pelo professor. 
	\begin{itemize}
		\item Link: http://web.stanford.edu/class/archive/cs/cs161/cs161.1178/
	\end{itemize}
\end{itemize}

\section{Radix Sort}

\textbf{(2pts) }Your job is to implement the radix sort algorithm in Python. The following code is going to be used to test your implementation. You have to submit a notebook with your code. 
  
\begin{lstlisting}[language=Python]
def radix_sort(A, d, k):
  # A consists of n d-digit ints, with digits ranging 0 -> k-1
  #
  # implement your code here
  # return A_sorted


# Testing your function
A = [201, 10, 3, 100]
A_sorted = radix_sort(A, 3, 10)
print(A_sorted)
# output: [3, 10, 100, 201]
\end{lstlisting}

\textbf{Resposta}:\\

Ver arquivo: radix\_sort.ipynb.\\

Como referências, usei:
\begin{itemize}
	\item Livro "Introduction to Algorithms", capítulo 8.4 (CORMEN, Thomas et al).
	\item Slide L3 do curso de Standford que está sendo utilizado pelo professor. 
	\begin{itemize}
		\item Link: http://web.stanford.edu/class/archive/cs/cs161/cs161.1178/
	\end{itemize}
\end{itemize}
  
 
Além do exemplo de teste fiz mais alguns com números naturais. O radix sort faz  recursão em cada dígito do conjunto de elementos da lista e chama bucket sort, que por sua vez cria uma chave-valor e usa o dígito como chave, chamando em seguida um stable sort em cada bucket gerado. Escolhi o insert sort dado que o foco não está na escolha do stable sort por algum critério específico. Nesse caso, o insertion sort ocupa menos linhas, tornando o código mais conciso de modo a visualizar suas outras partes.

\section{Sorting in Place in Linear Time}
\textbf{(1.5pts)} Suppose that we have an array of $n$ data records to sort and that the key of each record has the value 0 or 1. An algorithm for sorting such a set of records might possess some subset of the following three desirable characteristics:

\begin{enumerate}
  \item The algorithm runs in $O(n)$ time.
  \item The algorithm is stable.
  \item The algorithm sorts in place, using no more than a constant amount of storage space in addition to the original array.
\end{enumerate}

\begin{enumerate}[label=(\alph*)]
  \item Give an algorithm that satisfies criteria 1 and 2 above.
  \item Give an algorithm that satisfies criteria 1 and 3 above.
  \item Give an algorithm that satisfies criteria 2 and 3 above.
  \item Can any of your sorting algorithms from parts(a)–(c) be used to sort $n$ records with $b$-bit keys using radix sort in $O(bn)$ time? Explain how or why not.
  \item Suppose that the $n$ records have keys in the range from 1 to $k$. Show how to modify counting sort so that the records can be sorted in place in $O(n + k)$ time. You may use $O(k)$ storage outside the input array. Is your algorithm stable? (Hint: How would you do it for $k = 3$?)

\end{enumerate}

\textbf{Resposta}:\\

a) Nesse caso, podemos aplicar counting sort, dado que sabemos o número distinto de valores. Counting sort tem complexidade O(n) e é um stable sort, tal como demonstrado no livro.\\

b) Nesse caso específico, Quicksort pode ser aplicado uma única vez se escolhermos 0 como pivô, dado que isso vai separar a lista, deixando todos os 0s do lado esquerdo e todos os 1s do lado direito. Quicksort é sempre inplace. Sua complexidade em geral é O(nlogn), mas será O(n) neste caso. \\

c) Insertion sort é in place e também é conhecido como um stable sort.
\\

d) Counting sort. 
\\

e)


\section{Alternative Quicksort Analysis} 
\textbf{(1.5pts)} An alternative analysis of the running time of randomized quicksort focuses on the expected running time of each individual recursive call to QUICKSORT, rather than on the number of comparisons performed.

\begin{enumerate}[label=(\alph*)]
  \item Argue that, given an array of size $n$, the probability that any particular element is chosen as the pivot is $1/n$. Use this to define indicator random variables $X_i = I \{i\mbox{th smallest element is chosen as the pivot}\}$. What is $E[X_i]$?
  \item Let $T(n)$ be a random variable denoting the running time of quicksort on an array of size $n$. Argue that
  \begin{equation}
    E[T(n)]=E\left[\sum_{q=1}^{n}X_q(T(q-1)+T(n-q)+\Theta(n))\right]  
    \label{eq:1}
  \end{equation}
  
  \item Show that equation~\ref{eq:1} simplifies to
  \begin{equation}
    E[T(n)] = \frac{2}{n}\sum_{q=0}^{n-1}E[T(q)] + \Theta(n)
    \label{eq:2}
  \end{equation}

  \item Show that
  \begin{equation}
    \sum_{k=1}^{n-1} k \lg k \leq \frac{1}{2}n^2\lg n - \frac{1}{8}n^2
    \label{eq:3}
  \end{equation}
  (Hint: Split the summation into two parts, one for $k=1,2, \ldots, \lceil n/2 \rceil - 1$ and \\ one for $k=\lceil n/2 \rceil~,\ldots,~n-1.)$

  \item Using the bound from equation~\ref{eq:3}, show that the recurrence in equation~\ref{eq:2} has the solution $E[T(n)]=\Theta(n\lg n)$. (Hint: Show, by substitution, that $E[T(n)] \leq an \log n - bn$ for some positive constants $a$ and $b$.)
\end{enumerate}

\textbf{Respostas}:\\

ver livro , 118, 179\\


a)\\
Tal como explicado no livro "Introduction to Algorithms", capítulo 5 (CORMEN, Thomas et al), dado um espaço amostral S e um evento A, a Indicadora da variável aleatória I\{A\} associada ao evento A será definida por:

\[
 I\{A\}\ =
\left\{
\begin{array}{ll}
1& \textrm{se A ocorrer}\\
0& \textrm{se A não ocorrer}
\end{array}
\right.
\]

Neste caso, queremos encontrar o valor esperado do \textit{i-ésimo menor elemento a ser selecionado como pivô} ($A_{i}$). O espaço amostral é dado por S = \{$A_{1}, A_{2}, ..., A_{n}$\}, sendo a probabilidade de $A_{i} = \frac{1}{n}, \forall 1\leq i \leq  n$, pois as probabilidades de cada evento são todas iguais e, somadas, totalizam 1.
Podemos definir uma variável aleatória Xi associada ao evento $A_{i}$. Essa variável conta o número de vezes que o pivô 'i' será selecionado ao fazer a seleção, que será 1 em caso afirmativo, ou 0 caso contrário. Escrevemos então:

\[
X_{i} =
\left\{
\begin{array}{ll}
1& \textrm{se $A_{i}$ ocorrer}\\
0& \textrm{se $A_{i}$ não ocorrer}
\end{array}
\right.
\]

O número esperado de vezes que $A_{i}$ será selecionado como pivô é simplesmente o valor esperado da variável indicadora Xi:	 \\
\begin{align*}
& E[X_{i}] = E[I\{A_{i}\}] \\
& = 1\cdot Pr\{A_{i}\} + 0\cdot Pr\{A_{i}\}  \\
& = 1\cdot\frac{1}{n} + 0\cdot\frac{n-1}{n} \\
& = \frac{1}{n}\\
\end{align*}
Portanto, o número esperado de vezes que $A_{i}$ será selecionado como pivô é $\frac{1}{n}$ \\

b)\\
Primeiro, definindo T(n):\\
Relembrando o algoritmo quicksort:\\
QUICKSORT(A, p, r) \\
1. if p $<$ r: \\
2. ---- q = PARTITION(A, p, r) \\
3. ---- QUICKSORT(A, p, q-1) \\
4. ---- QUICKSORT(A, q+1, r) \\
Sendo que a chamada inicial da função é: QUICKSORT(A,1,A.length).\\
Não precisamos entrar em muitos detalhes sobre o PARTITION. Essencialmente, será definido um pivô "q" por meio do qual o array A será dividido entre os elementos menores do que 'q' (elementos q-1) e os maiores do que 'q' (elementos n-q), formando duas sublistas onde se dará nova recursão. Tal tarefa de particionamento tem custo linear, $\Theta(n)$\\
Portanto, a recursão de quicksort é:\\
\begin{equation}
 T(n) = T(q-1)+T(n-q)+\Theta(n)
\end{equation}

A partir daqui, sabemos uma das principais propriedades da expectância, a de linearidade. Basta aplicar sobre cada um dos eventos $X_{i}$ para chegarmos ao resultado:
\begin{equation}
E[T(n)]=E\left[\sum_{q=1}^{n}X_q(T(q-1)+T(n-q)+\Theta(n))\right]  
\end{equation}


c) rever. rever theta. rever linha 6 \\
\begin{align*}
&E[T(n)]=E\left[\sum_{q=1}^{n}X_q(T(q-1)+T(n-q)+\Theta(n))\right]   \\
&= \sum_{q=1}^n  E[X_q(T(q-1)+T(n-q)+\Theta(n))]\\
&= \sum_{q=1}^n \frac{(T(q-1)+T(n-q)+\Theta(n))}{n}\  \text{Usando o que foi demonstrado na letra 'a'} \\
&= \Theta(n)+\frac{1}{n} \sum_{q=1}^n(T(q-1)+T(n-1)) \\
&= \Theta(n)+\frac{1}{n} \left(\sum_{q=1}^n T(q-1)+\sum_{q=1}^nT(n-q) \right) \\
&= \Theta(n)+\frac{1}{n} \left(\sum_{q=1}^n T(q-1)+\sum_{q=1}^nT(q-1) \right) \\
&= \Theta(n)+\frac{1}{n} \sum_{q=1}^n 2\cdot T(q-1) \\
&= \Theta(n)+\frac{2}{n} \sum_{q=1}^n T(q-1) \\
&= \Theta(n)+\frac{2}{n} \sum_{q=0}^{n-1} T(q). \\
\end{align*}

d)

e)

Utilizando o método de substituição, estipulamos que $T(q) \le q \lg(q)-bn$ e assumimos por indução que a propriedade se mantém. Pela proposição "c", temos que:

\begin{align*}
\text E[T(n)]
& = \frac{2}{n} \sum_{q=0}^{n-1} \text E[T(q)] + \Theta(n) \\
& \le \frac{2}{n} \sum_{q=0}^{n-1}aq\lg q-bq + \Theta(n)\ \  \text{Aplicando substituição.}\\
& = \frac{2}{n} \sum_{q=1}^{n-1}aq\lg q -bq + \Theta(n) \\
& \le \frac{2}{n}(\frac{1}{2}an^2\lg n - \frac{a}{8}n^2 -\frac{bn^2}{2}) + \Theta(n)\  \text{Aplicando o resultado de "d".}\\
& = an\lg n -\frac{an}{4} - \frac{2}{n}\frac{bn^2}{2} + \Theta(n) \\
& = an\lg n - bn -\frac{an}{4} + \Theta(n) \\ 
& \le an\lg n - bn + \Theta(n),\ \forall a,b > 0\\
& = \Theta(n\lg n).
\end{align*}

%OLD
%\begin{align*}
%\text E[T(n)]
%& = \frac{2}{n} \sum_{q=0}^{n-1} \text E[T(q)] + \Theta(n) \\
%& \le \frac{2}{n} \sum_{q=0}^{n-1}aq\lg q-bn + \Theta(n)\ \  \text{Aplicando substituição.}\\
%& = \frac{2}{n} \sum_{q=1}^{n-1}aq\lg q -bn + \Theta(n) \\
%& \le \frac{2}{n}(\frac{1}{2}an^2\lg n - a\frac{1}{8}n^2 -(n-1)bn) + \Theta(n)\  \text{Aplicando o resultado de "d".}\\
%& = an\lg n -a\frac{1}{4}n - (n-1)b + \Theta(n) \\
%& = an\lg n - n(\frac{a}{4}+b) + b + \Theta(n) \text{REVER SE ESSE OU ABAIXO.} \\
%& = an\lg n - bn - a\frac{n}{4} + b + \Theta(n) \\
%& = an\lg n - bn - b(n+1) + \Theta(n)\ \  \text{Estipulando a > 4b.}\\
%& \le an\lg n - bn + \Theta(n)\ \\\
%& = \Theta(n\lg n).
%\end{align*}

\end{document}